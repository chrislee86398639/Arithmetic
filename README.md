# Arithmetic
实现一个自动生成小学四则运算题目的命令行程序

| 课程  | [软件工程](https://edu.cnblogs.com/campus/gdgy/informationsecurity1812/)|
| :-------------: | :-------------: |
| 要求  | [结对项目作业](https://edu.cnblogs.com/campus/gdgy/informationsecurity1812/homework/11157)|
| 题目  | 四则运算生成器  |


|人员|GitHub 链接|
| :-------------: | :-------------: |
|队长李文静|**https://github.com/EmmaZoeLeft/Arithmetic.git**|
|队员左梓仪|**https://github.com/EmmaZoeLeft/Arithmetic.git**|

## 一、题目要求及实现情况

- 输入
  *  参数控制生成的题目个数 [√]
    `Myapp.exe -n 10`
  *  参数控制题目中操作数的范围：自然数[√]、真分数[x]、真分数分母[x]
    `Myapp.exe -r 10`
- 生成
  * 生成的题目
    + 操作数：整数[√]、真分数[x]
    + 符号：四则运算符[√]、空格分隔符[√]、等号[√]、左右括号[？]
  * 一题中运算符个数不超过三个 [√]
  * 计算过程中不出现负数 [√]
  * 一次性生成的题目不含重复的 [√]
  * 能一次性生成一万道题 [√]
- 评卷
  * 一次性生成参数要求数量题目，控制台处做一题评一题，最终汇总答题情况 [√]
  * 对给定的题目文本和答案文本，评卷并输出总对错情况 [x]
      `Myapp.exe -e <exercisefile>.txt -a <answerfile>.txt`
- 表现/输出
  * 题目
    + 生成的题目输出为 .txt 文本 [√]
    + 题目文本格式为： [？]
      `1、四则运算题目1:`
      `2、四则运算题目2:`
  * 答案
    + 生成的答案输出为 .txt 文本 [√]
    + 答案文本格式为： [？]
      `1、答案1`
      `2、答案2`
  * 评卷
    + 生成的评卷情况输出为 .txt 文本 [√]
    + 评卷情况文本格式为： [√]
      `Correct:5(1,3,5,7,9)`
      `Wrong:5(2,4,5,6,8)`
      [其中“:”后面的数字5表示对/错的题目的数量，括号内的是对/错题目的编号。为简单起见，假设输入的题目都是按照顺序编号的符合规范的题目。]

## 二、设计及具体实现

### 1、开发
|功能|描述|实现者|
| :-------------: | :-------------: | :-------------: |
|随机生成题目|随机生成操作数和运算符，组成四则运算表达式|李文静|
|四则运算|根据式子运算并生成答案|李文静|
|题目查重剔除|剔除生成的重复式子|李文静|
|评卷功能|判断对错|李文静|
|单元测试与性能分析|测试每个方法是否成功实现，辅助查找程序故障|左梓仪|
|故障修复与性能优化|修复程序故障，实现性能优化|李文静|
|文档撰写|单元测试文档、性能分析文档、GitHub团队协作学习信息、博客|左梓仪|

### 2、程序结构
类的调用关系
  <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012220918389-25367232.png"   width="45%">

### 3、代码说明


## 三、单元测试
### 1、Calculate 类
- 测试方法：
  - `ToSuffixExpression` 中缀转后缀
  - `Calculate` 计算表达式的值
- 第一轮测试
  - 测试用例1 [3 * 2 + 2 / 1 - 2 - 1 =]
      + 估计：结果5/1 ，后缀[3, 2, *, 2, 1, / , +,2, -,1, -]
      + 实际：结果100000/1 ，后缀[3, 2, *, 2, 1, /, 2, -, 1, -, +]
      <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012155251924-1031399906.png"   width="55%">
      <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012155302175-509138934.png"   width="55%">

      + 分析：运算发现，**后缀表达式偏差，导致运算过程出现负数**，即运算过程违法，所以才导致运算结果不同，实际计算结果一致。`Calculate` 方法无错，是 `ToSuffixExpression` 方法的问题。需进一步排查是什么原因导致的表达式偏差。


  - 测试用例2 [3 * 2 + 2 / 1 - 2 + 1 =]
      + 估计：结果7/1 ，后缀[3, 2, *, 2, 1, / , +,2, -,1, +]
      + 实际：结果7/1 ，后缀[3, 2, *, 2, 1, /, 2, -, 1, +, +]
      <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012155534588-1692975922.png"   width="55%">
      
      + 分析：这一次后缀表达式不同而计算结果一致。仔细推导发现，导致偏差的根源出现在 `ToSuffixExpression` 方法的符号入栈对比上。**入栈对比遇到优先级较高的时，仅仅与前一位符号对比，没有与更之前的进行对比。**如此便导致优先级相同时，最左边的反而会沉到后缀表达式的最底下，有一定几率导致 e1-e2 子式中减数与被减数位置对调，出现负数。

- 第二轮测试
  - 测试用例1 [3 * 2 + 2 / 1 - 2 - 1 =]
      + 估计：结果5/1 ，后缀[3, 2, *, 2, 1, / , +,2, -,1, -]
      + 实际：结果5/1 ，后缀[3, 2, *, 2, 1, / , +,2, -,1, -]
      <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012205923757-1798144004.png"   width="45%">

      + 分析：断言都正确，全部方法均无错


  - 测试用例2 [1 + ( 5 - 3 - 1 ) =]
      + 估计：结果2/1 ，后缀[1, 5, 3, -, 1, -, +]
      + 实际：结果2/1 ，后缀[1, 5, 3, -, 1, -, +]
      <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012210513469-2134125249.png"   width="45%">
      <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012210527391-1723805833.png"   width="45%">

      + 分析：断言都正确，全部方法均无错


### 2、Expression 类
- 测试方法：
  - `generateExp` 生成原始表达式
  - `legalExp` 生成合法表达式
- 测试
  - 结果
  
    <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012155710703-1061868631.png"   width="45%">

    <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012155720049-574442010.png"   width="45%">    


  - 分析：能根据要求生成指定数量的题目，两个方法均无错

### 2、Fraction 类
- 测试方法：
  - `add` 加
  - `sub` 减
  - `muti` 乘
  - `div` 除
  - `Appointment` 分别约分分子分母
  - `transferFraction` 约分化简，真分数/带分数形式表示
- 测试
  - 结果
  
    <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012155911804-800009218.png"   width="45%"> 

  - 分析：断言都正确，全部方法均无错

  
## 四、效能分析
生成10000道题目时
- 内存
  <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012213134202-817231637.png"   width="55%"> 
- Classes
  <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012213345319-1135957003.png"   width="55%"> 
- GC
  <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012213529078-3820256.png"   width="55%"> 
- 线程
  <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012213559393-1882109193.png"   width="55%"> 
- CPU Load
  <img src="https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012213424211-1980806319.png"   width="55%"> 

## 五、项目小结

#### 李文静
    1、收获
    2、不足
    3、改进

#### 左梓仪
    1、收获
    通过单元测试找到故障并解决的经验、GitHub 多人团队开发的代码管理、性能分析工具学习、文档整理和信息整合能力得到加强
    2、不足
    具体功能开发是完全跟不上队友的进度，只能辅助进行单元测试，开发参与度极低，实质上并不算结对开发
    3、改进
    以后在开发过程中要做到及时沟通，一有不明白的立刻就问。时刻掌握队友的进度，把队友的代码当自己的，在自己开发过程中要能用上队友开发的功能
    4、结对感受
    我的这次结对感受是既愧疚又感动。由于自己跟不上进度，让文静承担了绝大多数的任务，我心里感到十分愧疚。就算是这样，文静仍然没有抛弃我，还努力教给了我非常多知识，我心里十分感动。文静真的是超级棒的一个队友/队长！



## 附录 PSP表
|PSP2.1|Personal Software Process Stages|预估耗时（分钟）|实际耗时（分钟）|
| :----: | :----: | :----: | :----: |
|Planning|计划||
|Estimate|估计这个任务需要多少时间|45|25|
|Development|开发||
|Analysis|需求分析 (包括学习新技术)|720|660|
|Design Spec|生成设计文档|120|30|
|Design Review|设计复审|60|0|
|Coding Standard|代码规范 (为目前的开发制定合适的规范)|30|0|
|Design|具体设计|120|240|
|Coding|具体编码|720|1080|
|Code Review|代码复审|240|360|
|Test|测试（自我测试，修改代码，提交修改）|720|240|
|Reporting|报告||
|Test Repor|测试报告|120|90|
|Size Measurement|计算工作量|45|20|
|Postmortem & Process Improvement Plan|事后总结, 并提出过程改进计划|60|30|
| |合计|3000|2775|![](https://img2020.cnblogs.com/blog/2148458/202010/2148458-20201012210314766-332364152.png)
